<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Two-Thumb Pong</title>
<style>
  :root{
    --bg1:#080e24; --bg2:#0f1a3f;
    --fg:#fff; --muted:#b9c4ff;
    --accentL:#69e0ff; --accentR:#9aff7a; --ball:#ffd86b;
    --chip:#151c35; --chip2:#0f1530;
    --danger:#ff4d4d; --ok:#33d17a;
    --shadow:0 10px 28px rgba(0,0,0,.4);
    --z-canvas:0; --z-lanes:1; --z-hud:10; --z-overlay:20; --z-count:25; --z-start:40;
  }
  *{box-sizing:border-box}
  /* Hard fix: hidden must truly hide in all contexts */
  [hidden]{display:none !important;}

  html,body{height:100%;margin:0;background:var(--bg1);color:var(--fg);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  body{overscroll-behavior:none; -webkit-user-select:none; user-select:none; touch-action:none}
  #wrap{position:fixed; inset:0; min-height:100dvh}

  /* Game */
  canvas#game{position:fixed; inset:0; width:100vw; height:100dvh; display:block; z-index:var(--z-canvas)}

  /* Decorative thumb lanes */
  .lanes{position:fixed; inset:0; display:flex; pointer-events:none; z-index:var(--z-lanes)}
  .lanes>div{flex:1; border-left:1px dashed rgba(255,255,255,.15); border-right:1px dashed rgba(255,255,255,.15)}
  .lanes>div:first-child{background:linear-gradient(180deg, rgba(105,224,255,.08), transparent 40%, rgba(105,224,255,.08))}
  .lanes>div:last-child{background:linear-gradient(180deg, rgba(154,255,122,.08), transparent 40%, rgba(154,255,122,.08))}

  /* HUD */
  .hud{position:fixed; inset:0; z-index:var(--z-hud)}
  .row{display:flex; align-items:center; justify-content:space-between;
    padding:calc(env(safe-area-inset-top,0px) + 10px) 12px 10px 12px; gap:8px}
  .score{font-variant-numeric:tabular-nums; text-align:center}
  .score .big{font-size:28px; font-weight:800; text-shadow:0 2px 0 rgba(0,0,0,.35)}
  .score .small{font-size:12px; color:var(--muted)}

  .btn{
    -webkit-tap-highlight-color:transparent;
    appearance:none; border:0; border-radius:14px; min-width:44px; min-height:44px;
    padding:12px 14px; font-weight:700; color:#fff; background:var(--chip); box-shadow:var(--shadow);
    display:inline-flex; align-items:center; justify-content:center; gap:8px; font-size:14px; cursor:pointer
  }
  .btn:active{transform:translateY(1px)}
  .btn.ghost{background:var(--chip2)}
  .btn.red{background:#2a0f16; color:#ffd6d6}
  .btn.green{background:#0e2a1d; color:#d6ffea}

  /* Start CTA above everything */
  .bottom-cta{position:fixed; left:50%; transform:translateX(-50%);
    bottom:calc(env(safe-area-inset-bottom,0px) + 18px); z-index:var(--z-start)}
  .bottom-cta .btn{font-size:16px; padding:16px 22px; border-radius:16px}

  /* Overlays */
  .overlay{position:fixed; inset:0; display:grid; place-items:center;
    background:rgba(5,8,20,.64); backdrop-filter:blur(6px); padding:24px; z-index:var(--z-overlay)}
  .panel{width:min(92vw,520px); border-radius:18px; background:#0e1735; box-shadow:var(--shadow); padding:20px}
  .panel h1{margin:0 0 4px 0; font-size:22px}
  .panel p{margin:8px 0; color:var(--muted)}
  .panel .actions{display:flex; gap:10px; margin-top:14px; flex-wrap:wrap}
  .tag{display:inline-block; font-size:12px; padding:6px 10px; border-radius:999px; background:#0b132b; color:#var(--muted); margin-right:6px; margin-top:6px}

  /* Countdown */
  .countdown{position:fixed; inset:0; display:grid; place-items:center; z-index:var(--z-count); pointer-events:none;
    font-weight:900; font-size:18vw; line-height:1; color:#fff; text-shadow:0 10px 40px rgba(0,0,0,.55)}

  /* Speed meter */
  .meter{position:fixed; top:calc(env(safe-area-inset-top,0px) + 60px); left:50%; transform:translateX(-50%);
    width:min(70vw,420px); height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; z-index:var(--z-hud)}
  .meter>i{display:block; height:100%; width:0%; background:linear-gradient(90deg,#7cf8ff,#ffd86b,#ff8ab5); transition:width .15s}

  @media (max-width:420px){ .score .big{font-size:24px} .btn{padding:10px 12px} }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
  <div class="lanes" aria-hidden="true"><div></div><div></div></div>

  <div class="hud" aria-live="polite">
    <div class="row">
      <div class="cluster">
        <button class="btn ghost" id="btnHelp" aria-label="How to play">‚ùì</button>
        <button class="btn ghost" id="btnSettings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
      <div class="score">
        <div class="big"><span id="score">0</span></div>
        <div class="small">Best <span id="best">0</span> ‚Ä¢ Lv <span id="lvl">1</span></div>
      </div>
      <div class="cluster">
        <button class="btn" id="btnPause" aria-label="Pause">‚è∏Ô∏è</button>
        <button class="btn red" id="btnRestart" aria-label="Restart">‚Üª</button>
      </div>
    </div>
    <div class="meter"><i id="speedBar"></i></div>
  </div>

  <!-- Start CTA -->
  <div class="bottom-cta">
    <button class="btn green" id="btnStart" role="button">‚ñ∂ Tap to Start</button>
  </div>

  <div id="countdown" class="countdown" hidden>3</div>

  <!-- Help -->
  <div id="help" class="overlay" hidden>
    <div class="panel">
      <h1>Two-Thumb Pong</h1>
      <p>Drag with your left and right thumbs on each half of the screen to move the two pucks. Keep the ball bouncing. Each hit = +1.</p>
      <div>
        <span class="tag">Spin from off-center hits</span>
        <span class="tag">Speed ramps by level</span>
        <span class="tag">Pause anytime</span>
      </div>
      <div class="actions">
        <button class="btn green" id="helpPlay">Play</button>
        <button class="btn ghost" id="helpClose">Close</button>
      </div>
    </div>
  </div>

  <!-- Settings -->
  <div id="settings" class="overlay" hidden>
    <div class="panel">
      <h1>Settings</h1>
      <p>Sound, vibration, and data.</p>
      <div class="actions">
        <button class="btn" id="toggleSound">üîä Sound: <span id="soundState">On</span></button>
        <button class="btn" id="toggleVib">üì≥ Vibration: <span id="vibState">On</span></button>
        <button class="btn ghost" id="resetBest">üóëÔ∏è Reset Best</button>
        <button class="btn ghost" id="settingsClose">Close</button>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameover" class="overlay" hidden>
    <div class="panel">
      <h1>Game Over</h1>
      <p>Score: <strong id="finalScore">0</strong></p>
      <p>Best: <strong id="finalBest">0</strong> <span id="newBestTag" class="tag" style="display:none">New Best!</span></p>
      <div class="actions">
        <button class="btn green" id="again">Play Again</button>
        <button class="btn" id="shareBtn" style="display:none">üì§ Share</button>
        <button class="btn ghost" id="overClose">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Storage / UX ---------- */
const store = {
  get(k, d){ try{const v=localStorage.getItem(k); return v===null?d:JSON.parse(v)}catch{ return d } },
  set(k, v){ try{localStorage.setItem(k, JSON.stringify(v))}catch{} }
};
const settings = { sound: store.get('tt_sound', true), vibrate: store.get('tt_vibe', true) };
let best = store.get('tt_best', 0);
let audioCtx = null;
function ping(freq=440, dur=0.06, vol=0.08){
  if(!settings.sound) return;
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
    osc.type='sine'; osc.frequency.value=freq;
    gain.gain.setValueAtTime(0,t0); gain.gain.linearRampToValueAtTime(vol,t0+0.005); gain.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
    osc.connect(gain).connect(audioCtx.destination); osc.start(t0); osc.stop(t0+dur);
  }catch{}
}
function vibrate(ms=15){ if(settings.vibrate && navigator.vibrate) navigator.vibrate(ms); }

/* ---------- DOM ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false, desynchronized:true});
const $ = s => document.querySelector(s);
const elScore=$('#score'), elBest=$('#best'), elLvl=$('#lvl'), elBar=$('#speedBar');
const elStart=$('#btnStart'), elPause=$('#btnPause'), elRestart=$('#btnRestart');
const elBtnHelp=$('#btnHelp'), elBtnSettings=$('#btnSettings');
const elHelp=$('#help'), elSettings=$('#settings'), elGameOver=$('#gameover');
const elHelpPlay=$('#helpPlay'), elHelpClose=$('#helpClose');
const elSettingsClose=$('#settingsClose'), elToggleSound=$('#toggleSound'), elSoundState=$('#soundState');
const elToggleVib=$('#toggleVib'), elVibState=$('#vibState'), elResetBest=$('#resetBest');
const elFinalScore=$('#finalScore'), elFinalBest=$('#finalBest'), elNewBestTag=$('#newBestTag');
const elAgain=$('#again'), elOverClose=$('#overClose'), elShare=$('#shareBtn');
const elCountdown=$('#countdown');
const startCta = document.querySelector('.bottom-cta');

elBest.textContent = best;
elSoundState.textContent = settings.sound?'On':'Off';
elVibState.textContent = settings.vibrate?'On':'Off';

/* ---------- Game State ---------- */
const GameState = { Ready:0, Countdown:1, Playing:2, Paused:3, Over:4 };
let state = GameState.Ready;
let score = 0, level = 1;
let lastT=0, raf=null;
let countdownT=0, countdownVal=3;
let DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
let wakeLock = null;

const world = {
  w:0,h:0, margin:22,
  ball:{x:0,y:0,r:10,vx:360,vy:0,speed:360,speedMax:1500,trail:[]},
  left:{x:0,y:0,r:30,color:getCSS('--accentL')},
  right:{x:0,y:0,r:30,color:getCSS('--accentR')},
  top:0,bottom:0,
};
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim() }

/* ---------- Resize ---------- */
function fit(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  const cssW = window.innerWidth, cssH = window.innerHeight;
  canvas.width = Math.floor(cssW*DPR); canvas.height = Math.floor(cssH*DPR);
  canvas.style.width = cssW+'px'; canvas.style.height = cssH+'px';
  ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);

  world.w = cssW; world.h = cssH;
  world.top = world.margin; world.bottom = cssH - world.margin;
  const edge = 36;
  world.left.x = edge; world.right.x = cssW - edge;
  world.left.y = cssH/2; world.right.y = cssH/2;

  if(state===GameState.Ready || state===GameState.Over){ placeBall(true); render(0); }
}
addEventListener('resize', fit, {passive:true});
fit();

/* ---------- Controls ---------- */
function openOverlay(el){ el.hidden=false; el.setAttribute('aria-hidden','false'); }
function closeOverlay(el){ el.hidden=true; el.setAttribute('aria-hidden','true'); }

elBtnHelp.onclick = ()=> openOverlay(elHelp);
elHelpClose.onclick = ()=> closeOverlay(elHelp);
elHelpPlay.onclick = ()=> { closeOverlay(elHelp); startFlow(); };

elBtnSettings.onclick = ()=> openOverlay(elSettings);
elSettingsClose.onclick = ()=> closeOverlay(elSettings);
elToggleSound.onclick = ()=> { settings.sound=!settings.sound; store.set('tt_sound',settings.sound); elSoundState.textContent=settings.sound?'On':'Off'; ping(660,.05,.12); };
elToggleVib.onclick = ()=> { settings.vibrate=!settings.vibrate; store.set('tt_vibe',settings.vibrate); elVibState.textContent=settings.vibrate?'On':'Off'; vibrate(15); };
elResetBest.onclick = ()=> { best=0; store.set('tt_best',0); elBest.textContent='0'; };

elStart.onclick = ()=> startFlow();
elRestart.onclick = ()=> resetGame(true);
elPause.onclick = ()=> togglePause();
elAgain.onclick = ()=> { closeOverlay(elGameOver); resetGame(true); };
elOverClose.onclick = ()=> closeOverlay(elGameOver);

if(navigator.share) elShare.style.display='inline-flex';
elShare.onclick = async ()=>{ try{ await navigator.share({title:'Two-Thumb Pong', text:`I scored ${score}!`, url:location.href}); }catch{} };

/* ---------- Wake Lock ---------- */
async function lockScreen(){ try{ if('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); } }catch{} }
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && state===GameState.Paused) scheduleLoop(); });

/* ---------- Start / Flow ---------- */
function startFlow(){
  if(state===GameState.Playing || state===GameState.Countdown) return;
  closeOverlay(elHelp); closeOverlay(elSettings); closeOverlay(elGameOver);
  startCta.hidden = true;
  startCountdown();
  lockScreen();
}
function startCountdown(){
  state = GameState.Countdown;
  countdownVal = 3; elCountdown.hidden=false; elCountdown.textContent = countdownVal;
  countdownT = performance.now(); ping(660,.08,.12);
  scheduleLoop();
}
function beginPlay(){
  state = GameState.Playing;
  elCountdown.hidden=true;
  startCta.hidden = true;
  lastT = performance.now();
  ping(900,.06,.12);
}
function togglePause(){
  if(state===GameState.Playing){ state=GameState.Paused; elPause.textContent='‚ñ∂Ô∏è'; }
  else if(state===GameState.Paused){ state=GameState.Playing; lastT=performance.now(); elPause.textContent='‚è∏Ô∏è'; scheduleLoop(); }
}
function gameOver(){
  state = GameState.Over;
  ping(160,.12,.15); vibrate(40);
  best = Math.max(best, score); store.set('tt_best', best);
  elFinalScore.textContent = score; elFinalBest.textContent = best;
  elBest.textContent = best; elNewBestTag.style.display = (score===best && score>0)?'inline-block':'none';
  openOverlay(elGameOver);
  startCta.hidden = false;
}
function resetGame(andCountdown=false){
  score=0; level=1; elScore.textContent=score; elLvl.textContent=level; elBar.style.width='0%';
  world.ball.trail.length=0; placeBall(true);
  state=GameState.Ready; elPause.textContent='‚è∏Ô∏è';
  startCta.hidden = andCountdown ? true : false;
  if(andCountdown) startCountdown(); else render(0);
}
function placeBall(randomDir=false){
  const b=world.ball;
  b.x = world.w/2; b.y = world.h/2; b.r = 11;
  b.speed = 360; b.speedMax = 1600;
  const dir = randomDir ? (Math.random()<0.5?-1:1) : 1;
  b.vx = dir * b.speed; b.vy = (Math.random()*2-1)*120;
}

/* ---------- Input (touch + mouse) ---------- */
function sideFromX(x){ return x < (world.w/2) ? 'L' : 'R'; }
function clampY(y){ return Math.max(world.top, Math.min(world.bottom, y)); }
function movePuck(side, y){ if(side==='L') world.left.y = clampY(y); else world.right.y = clampY(y); }

canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  for(const t of e.changedTouches){
    const x=t.clientX-rect.left, y=t.clientY-rect.top;
    movePuck(sideFromX(x), y);
  }
},{passive:false});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  for(const t of e.changedTouches){
    const x=t.clientX-rect.left, y=t.clientY-rect.top;
    movePuck(sideFromX(x), y);
  }
},{passive:false});

let mouseL=false, mouseR=false;
canvas.addEventListener('mousedown', e=>{
  const r = canvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  if(sideFromX(x)==='L') mouseL=true; else mouseR=true; movePuck(sideFromX(x), y);
});
canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  if(mouseL && x<world.w/2) movePuck('L', y);
  if(mouseR && x>=world.w/2) movePuck('R', y);
});
addEventListener('mouseup', ()=>{ mouseL=false; mouseR=false; });

/* ---------- Physics ---------- */
function onHit(sideDy){
  score++; elScore.textContent=score;
  const b=world.ball;
  if(score%8===0){ level++; elLvl.textContent=level; b.speedMax+=40; }
  elBar.style.width = Math.min(100, Math.round((b.speed/b.speedMax)*100)) + '%';
  ping(740,.04,.09); vibrate(12);
  spawnBurst(b.x, b.y, sideDy>0?world.right.color:world.left.color);
}
function onMiss(){ gameOver(); }

function step(dt){
  if(state===GameState.Countdown){
    const now=performance.now();
    if(now-countdownT>=1000){
      countdownT+=1000; countdownVal--;
      if(countdownVal>0){ elCountdown.textContent=countdownVal; ping(660,.06,.12); }
      else{ beginPlay(); }
    }
    return;
  }
  if(state!==GameState.Playing) return;

  const b=world.ball, L=world.left, R=world.right;

  b.x += b.vx*dt; b.y += b.vy*dt;

  b.trail.push({x:b.x,y:b.y, t:0.35});
  if(b.trail.length>24) b.trail.shift();
  for(const p of b.trail){ p.t -= dt; }
  while(b.trail.length && b.trail[0].t<=0) b.trail.shift();

  if(b.y-b.r<=world.top){ b.y=world.top+b.r; b.vy=Math.abs(b.vy); ping(520,.03,.07); }
  if(b.y+b.r>=world.bottom){ b.y=world.bottom-b.r; b.vy=-Math.abs(b.vy); ping(520,.03,.07); }

  if(b.vx<0 && b.x-b.r<=L.x+L.r){
    const dy=b.y-L.y;
    if(Math.abs(dy)<=L.r+b.r){
      b.x=L.x+L.r+b.r; b.vx=Math.abs(b.vx);
      b.vy += dy*4.2; accelerate(b,1.045); onHit(dy);
    }
  }
  if(b.vx>0 && b.x+b.r>=R.x-R.r){
    const dy=b.y-R.y;
    if(Math.abs(dy)<=R.r+b.r){
      b.x=R.x-R.r-b.r; b.vx=-Math.abs(b.vx);
      b.vy += dy*4.2; accelerate(b,1.045); onHit(dy);
    }
  }

  if(b.x+b.r<0 || b.x-b.r>world.w) onMiss();

  updateParticles(dt);
}
function accelerate(b,f){
  b.speed = Math.min(b.speedMax, Math.hypot(b.vx,b.vy)*f);
  const ang=Math.atan2(b.vy,b.vx);
  b.vx=Math.cos(ang)*b.speed; b.vy=Math.sin(ang)*b.speed;
}

/* ---------- Particles ---------- */
const particles=[];
function spawnBurst(x,y,color){
  for(let i=0;i<16;i++){
    const a = Math.random()*Math.PI*2;
    particles.push({
      x,y, vx:Math.cos(a)*(60+Math.random()*160), vy:Math.sin(a)*(60+Math.random()*160),
      life:0.35+Math.random()*0.25, color, r:1+Math.random()*2
    });
  }
}
function updateParticles(dt){
  for(const p of particles){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy*=0.98; p.life-=dt; }
  while(particles.length && particles[0].life<=0) particles.shift();
}

/* ---------- Render ---------- */
function render(dt){
  const w=world.w, h=world.h;

  const g=ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, getCSS('--bg1')); g.addColorStop(1, getCSS('--bg2'));
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);

  ctx.globalAlpha=.1; ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.setLineDash([6,8]);
  ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke(); ctx.setLineDash([]); ctx.globalAlpha=1;
  ctx.globalAlpha=.12; ctx.fillStyle='#fff';
  ctx.fillRect(0, world.top-4, w, 4); ctx.fillRect(0, world.bottom, w, 4); ctx.globalAlpha=1;

  drawPuck(world.left.x, world.left.y, world.left.r, world.left.color);
  drawPuck(world.right.x, world.right.y, world.right.r, world.right.color);

  for(let i=0;i<world.ball.trail.length;i++){
    const p=world.ball.trail[i]; const a=Math.max(0, p.t)/0.35;
    ctx.globalAlpha=a*0.5; drawBall(p.x,p.y, world.ball.r*(0.7+a*0.3)); ctx.globalAlpha=1;
  }
  drawBall(world.ball.x, world.ball.y, world.ball.r);

  for(const p of particles){
    ctx.globalAlpha = Math.max(0, p.life*2.2);
    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
}
function drawPuck(x,y,r,color){
  ctx.shadowColor=color; ctx.shadowBlur=20;
  ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
}
function drawBall(x,y,r){
  ctx.shadowColor=getCSS('--ball'); ctx.shadowBlur=18;
  const grd=ctx.createRadialGradient(x-r/3,y-r/3,r*0.2,x,y,r);
  grd.addColorStop(0,'#fff6d0'); grd.addColorStop(1,getCSS('--ball'));
  ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
}

/* ---------- Loop ---------- */
function loop(t){
  if(state===GameState.Paused){ raf=null; return; }
  if(!lastT) lastT=t;
  const dt=Math.min(0.033,(t-lastT)/1000); lastT=t;
  step(dt); render(dt); scheduleLoop();
}
function scheduleLoop(){ if(!raf) raf = requestAnimationFrame(ts=>{ raf=null; loop(ts); }); }

/* ---------- Boot ---------- */
placeBall(true); render(0);
document.addEventListener('gesturestart', e=>e.preventDefault());
document.addEventListener('dblclick', e=>e.preventDefault(), {passive:false});
addEventListener('pointerdown', ()=>{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }, {once:true});

/* Fallback: start on any tap outside overlay panels (capture so it wins) */
document.addEventListener('pointerdown', (e)=>{
  const onPanel = e.target.closest('.panel');
  if(!onPanel && (state===GameState.Ready || state===GameState.Over)) startFlow();
}, true);

/* Keyboard for desktop testing */
addEventListener('keydown', e=>{
  if(e.code==='Space'){ if(state===GameState.Playing) togglePause(); else startFlow(); }
  if(e.code==='KeyR') resetGame(true);
});

/* ---------- Draw idle ---------- */
render(0);
</script>
</body>
</html>
