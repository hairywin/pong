<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Two-Thumb Pong (Solo)</title>
<style>
  :root{
    --bg1:#0f1222; --bg2:#1a2040; --fg:#e6e8ef; --muted:#9aa3b2; --accent:#58d3ff;
    --puck:#7ae0ff; --rim:rgba(255,255,255,.15); --net:rgba(255,255,255,.12);
  }
  /* High-contrast theme */
  .contrast{
    --bg1:#000; --bg2:#111; --fg:#fff; --muted:#b9c1cc; --accent:#fff;
    --puck:#fff; --rim:rgba(88,211,255,.7); --net:rgba(255,255,255,.25);
  }

  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;overflow:hidden;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #wrap{position:fixed;inset:0;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
  #canvas{display:block;width:100%;height:100%}

  /* HUD */
  #hud{position:fixed;left:0;right:0;top:0;padding:calc(8px + env(safe-area-inset-top)) 10px 6px;display:flex;gap:8px;align-items:center;justify-content:space-between;pointer-events:none}
  #leftHud,#rightHud{display:flex;align-items:center;gap:10px}
  #score{font-weight:800;font-size:20px;letter-spacing:.4px}
  #best{font-size:12px;color:var(--muted)}
  #stats{font-size:11px;color:var(--muted)}
  #sparkline{width:84px;height:22px;border-radius:6px;background:rgba(255,255,255,.06);outline:1px solid rgba(255,255,255,.06)}
  /* Zones hint + thumb labels */
  .zone{position:fixed;top:0;bottom:0;width:50vw;opacity:.06;pointer-events:none;transition:opacity .6s ease}
  .zone.left{left:0;background:radial-gradient(120vw 120vh at 0% 50%,#fff,transparent)}
  .zone.right{right:0;background:radial-gradient(120vw 120vh at 100% 50%,#fff,transparent)}
  .thumbLabel{position:fixed;top:50%;transform:translateY(-50%);font-weight:900;font-size:12vw;opacity:.18;letter-spacing:.08em;pointer-events:none;user-select:none;transition:opacity 1.5s ease}
  #lblLeft{left:4vw}
  #lblRight{right:4vw}

  /* Overlays */
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(5,7,15,.6);backdrop-filter:blur(4px)}
  .card{width:min(92vw,520px);background:#0e1225;border:1px solid #222a4e;border-radius:16px;box-shadow:0 10px 30px #0007;padding:20px;text-align:center}
  .contrast .card{background:#0d0f14;border-color:#262a33}
  .card h1{margin:0 0 6px;font-size:22px}
  .card p{margin:6px 0 14px;color:var(--muted);line-height:1.4}
  .btn{display:inline-block;border:0;border-radius:14px;padding:14px 18px;font-weight:700;cursor:pointer}
  .btn.primary{background:var(--accent);color:#020611}
  .btn.ghost{background:transparent;color:var(--fg);border:1px solid #2c355f}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .statsrow{display:flex;gap:16px;justify-content:center;margin-top:10px;color:var(--muted);font-size:13px}

  /* Countdown */
  #countdown{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(5,7,15,.35);pointer-events:none}
  #countNum{font-weight:900;line-height:1;text-shadow:0 12px 40px rgba(0,0,0,.5);font-size:min(28vw,160px);color:#fff;animation:pop .8s ease both}
  @keyframes pop{0%{transform:scale(.4);opacity:0}60%{transform:scale(1.1);opacity:1}100%{transform:scale(1);opacity:.9}}

  /* Danger vignette */
  #danger{position:fixed;inset:0;pointer-events:none;background:radial-gradient(120vw 120vh at 50% 50%, transparent 40%, rgba(255,75,75,.28) 75%);opacity:0;transition:opacity .12s}
  /* NEW BEST toast */
  #toast{position:fixed;left:50%;top:calc(10px + env(safe-area-inset-top));transform:translateX(-50%);background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);padding:10px 14px;border-radius:12px;font-weight:800;backdrop-filter:blur(8px);display:none}
  /* Pause overlay */
  #pauseOverlay{display:none}

  /* Quick retry fixed button */
  #quickRetry{position:fixed;left:50%;bottom:calc(12px + env(safe-area-inset-bottom));transform:translateX(-50%);z-index:5;display:none}
  #quickRetry .btn{padding:16px 20px;border-radius:16px}

  /* Tip */
  #tip{position:fixed;left:0;right:0;bottom:calc(8px + env(safe-area-inset-bottom));text-align:center;color:var(--muted);font-size:12px;pointer-events:none}

</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div id="leftHud">
      <div id="score">0</div>
      <div id="best">Best: <span id="bestVal">0</span></div>
      <div id="stats">Run: <span id="runRallies">0</span> • Longest: <span id="longest">0</span> • Avg: <span id="avg">0</span></div>
    </div>
    <div id="rightHud">
      <canvas id="sparkline"></canvas>
    </div>
  </div>

  <!-- Touch zone hints + labels -->
  <div class="zone left" aria-hidden="true"></div>
  <div class="zone right" aria-hidden="true"></div>
  <div id="lblLeft" class="thumbLabel">LEFT</div>
  <div id="lblRight" class="thumbLabel">RIGHT</div>

  <!-- Danger + Toast -->
  <div id="danger" aria-hidden="true"></div>
  <div id="toast">NEW BEST</div>

  <!-- Tip -->
  <div id="tip">Use both thumbs. Touch left/right halves to move each puck.</div>

  <!-- Start -->
  <div id="startOverlay" class="overlay">
    <div class="card">
      <h1>Two-Thumb Pong</h1>
      <p>Keep the ball bouncing between your left and right pucks. Miss either side and the run ends.</p>
      <div class="statsrow"><span>Drag anywhere on each half</span><span>Speed ramps up</span></div>
      <div class="row" style="margin-top:12px">
        <button id="startBtn" class="btn primary">Start</button>
        <button id="muteBtn" class="btn ghost" aria-pressed="false">Sound: Off</button>
        <button id="contrastBtn" class="btn ghost" aria-pressed="false">High Contrast: Off</button>
        <button id="motionBtn" class="btn ghost" aria-pressed="false">Reduce Motion: Off</button>
        <button id="fsBtn" class="btn ghost" aria-pressed="false">Fullscreen: Try</button>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOverOverlay" class="overlay" style="display:none">
    <div class="card">
      <h1>Game Over</h1>
      <p id="finalLine">Score: 0</p>
      <div class="row">
        <button id="restartBtn" class="btn primary">Restart</button>
        <button id="shareBtn" class="btn ghost">Share</button>
      </div>
    </div>
  </div>

  <!-- Pause -->
  <div id="pauseOverlay" class="overlay">
    <div class="card">
      <h1>Paused</h1>
      <p>Two-finger tap again or press Resume.</p>
      <div class="row">
        <button id="resumeBtn" class="btn primary">Resume</button>
      </div>
    </div>
  </div>

  <!-- Countdown -->
  <div id="countdown"><div id="countNum">3</div></div>

  <!-- Quick Retry -->
  <div id="quickRetry"><button class="btn primary" id="quickBtn">Quick Restart</button></div>
</div>

<script>
(() => {
  const root = document.documentElement;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('bestVal');
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const finalLine = document.getElementById('finalLine');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const shareBtn = document.getElementById('shareBtn');
  const muteBtn = document.getElementById('muteBtn');
  const contrastBtn = document.getElementById('contrastBtn');
  const motionBtn = document.getElementById('motionBtn');
  const fsBtn = document.getElementById('fsBtn');
  const countdown = document.getElementById('countdown');
  const countNum = document.getElementById('countNum');
  const danger = document.getElementById('danger');
  const toast = document.getElementById('toast');
  const quickRetry = document.getElementById('quickRetry');
  const quickBtn = document.getElementById('quickBtn');
  const lblLeft = document.getElementById('lblLeft');
  const lblRight = document.getElementById('lblRight');
  const sparkline = document.getElementById('sparkline');
  const sctx = sparkline.getContext('2d');
  const runRalliesEl = document.getElementById('runRallies');
  const longestEl = document.getElementById('longest');
  const avgEl = document.getElementById('avg');

  // Persistent settings
  let muted = (localStorage.getItem('two_thumb_muted')||'1') === '1';
  let highContrast = (localStorage.getItem('two_thumb_contrast')||'0') === '1';
  let reduceMotion = (localStorage.getItem('two_thumb_motion')||'0') === '1';

  // State
  let W=0, H=0, DPR=1, unit=0;
  let running=false, gameOver=false, paused=false, tPrev=0;
  let leftY=0, rightY=0, paddleR=0, ballR=0;
  let ballX=0, ballY=0, vx=0, vy=0, speed=0, speedTarget=0, speedMax=0;
  let score=0, best=Number(localStorage.getItem('two_thumb_best')||0);
  let longest=Number(localStorage.getItem('two_thumb_longest')||0);
  let lastScores=JSON.parse(localStorage.getItem('two_thumb_last10')||'[]'); // array of ints

  // Effects
  let particles=[]; // sparks + confetti
  let shakeT=0; // ms remaining
  let perfSkip=false; // frame-level reduce motion

  bestEl.textContent = best;
  longestEl.textContent = longest;
  avgEl.textContent = avgFromLast(lastScores).toFixed(0);

  // Audio lightweight
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx = null;
  function ping(freq, dur=0.06, type='sine'){
    if(muted) return;
    actx = actx || new AudioCtx();
    const o = actx.createOscillator();
    const g = actx.createGain();
    // small variation to reduce monotony
    const varPct = 1 + (Math.random()*0.12 - 0.06);
    o.type = type;
    o.frequency.value = Math.max(80, freq*varPct);
    o.connect(g); g.connect(actx.destination);
    g.gain.value = 0.15;
    o.start();
    setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime + dur); }, 0);
    setTimeout(()=>{ o.stop(); }, dur*1000+20);
  }
  function vibrate(pattern){ if(navigator.vibrate) navigator.vibrate(pattern); }

  // Resize
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    canvas.width = Math.floor(cssW * DPR);
    canvas.height = Math.floor(cssH * DPR);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    W = cssW; H = cssH; unit = Math.min(W,H);
    paddleR = Math.max(24, unit*0.065);
    ballR   = Math.max(10, unit*0.018);
    leftY = leftY? Math.max(paddleR, Math.min(H-paddleR, leftY)) : H/2;
    rightY= rightY? Math.max(paddleR, Math.min(H-paddleR, rightY)) : H/2;

    // HUD sparkline scale
    sparkline.width = 84 * DPR;
    sparkline.height = 22 * DPR;
    sparkline.style.width = '84px';
    sparkline.style.height = '22px';
    sctx.setTransform(DPR,0,0,DPR,0,0);
    drawSparkline();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Touch control maps
  const touchSide = new Map(); // id -> 'L' | 'R'
  let twoFingerLock=false; // to avoid rapid toggles
  function handleTouches(list){
    for(let i=0;i<list.length;i++){
      const t = list[i];
      const x = t.clientX, y = t.clientY;
      const side = (x < W/2) ? 'L' : 'R';
      touchSide.set(t.identifier, side);
      if(side==='L'){ leftY = clamp(y, paddleR, H-paddleR); }
      else { rightY = clamp(y, paddleR, H-paddleR); }
    }
    // two-finger pause: both sides active
    if(running && !gameOver && !twoFingerLock){
      const sides = new Set([...touchSide.values()]);
      if(sides.has('L') && sides.has('R')){
        twoFingerLock = true;
        togglePause(true);
        setTimeout(()=>twoFingerLock=false, 450);
      }
    }
  }
  function moveTouches(list){
    for(let i=0;i<list.length;i++){
      const t = list[i];
      const side = touchSide.get(t.identifier) || ((t.clientX<W/2)?'L':'R');
      if(side==='L'){ leftY = clamp(t.clientY, paddleR, H-paddleR); }
      else { rightY = clamp(t.clientY, paddleR, H-paddleR); }
    }
  }
  function endTouches(list){
    for(let i=0;i<list.length;i++){ touchSide.delete(list[i].identifier); }
  }
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouches(e.changedTouches); }, {passive:false});
  canvas.addEventListener('touchmove',  (e)=>{ e.preventDefault(); moveTouches(e.changedTouches); },   {passive:false});
  canvas.addEventListener('touchend',   (e)=>{ e.preventDefault(); endTouches(e.changedTouches); },    {passive:false});
  canvas.addEventListener('touchcancel',(e)=>{ e.preventDefault(); endTouches(e.changedTouches); },    {passive:false});

  // Desktop fallback
  let mouseDown=false;
  canvas.addEventListener('mousedown', e=>{ mouseDown=true; (e.clientX<W/2? leftY=clamp(e.clientY,paddleR,H-paddleR): rightY=clamp(e.clientY,paddleR,H-paddleR)); });
  window.addEventListener('mouseup', ()=>mouseDown=false);
  window.addEventListener('mousemove', e=>{ if(!mouseDown) return; (e.clientX<W/2? leftY=clamp(e.clientY,paddleR,H-paddleR): rightY=clamp(e.clientY,paddleR,H-paddleR)); });
  const keys = {};
  window.addEventListener('keydown',e=>{ keys[e.key]=true; if(e.key===' ' && running && !gameOver) togglePause(!paused); });
  window.addEventListener('keyup',e=>{ keys[e.key]=false; });

  // Utils
  const clamp = (v,min,max)=> v<min?min:v>max?max:v;
  const lerp = (a,b,t)=> a+(b-a)*t;
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const nowMs = ()=>performance.now();

  function avgFromLast(arr){
    if(!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0)/arr.length;
  }

  // Game init
  function serve(){
    score = 0;
    scoreEl.textContent = '0';
    runRalliesEl.textContent = '0';
    leftY = H*0.5; rightY = H*0.5;
    const dir = Math.random()<0.5? -1: 1;
    ballX = W*0.5 + dir*unit*0.05;
    ballY = H*0.5;
    const angle = (Math.random()*0.6 - 0.3);
    speed = Math.max(220, unit*0.36);
    speedTarget = speed;
    speedMax = Math.max(600, unit*0.9);
    vx = dir * speed * Math.cos(angle);
    vy = speed * Math.sin(angle);
    gameOver = false;
    paused = false;
    particles.length = 0;
    danger.style.opacity = 0;
    // thumb labels fade in then out
    lblLeft.style.opacity = 0.18;
    lblRight.style.opacity = 0.18;
    requestAnimationFrame(()=>{ lblLeft.style.opacity = 0; lblRight.style.opacity = 0; });
  }

  // Countdown -> start
  async function begin(){
    startOverlay.style.display='none';
    gameOverOverlay.style.display='none';
    quickRetry.style.display='none';
    serve();
    // fullscreen attempt if requested
    if(fsWanted() && !document.fullscreenElement){
      try{ await document.documentElement.requestFullscreen(); }catch{}
    }
    // show countdown
    countdown.style.display='flex';
    for(let n=3;n>=1;n--){
      countNum.textContent = n;
      countNum.style.animation = 'none'; void countNum.offsetWidth;
      countNum.style.animation = 'pop .8s ease both';
      if(!muted) ping(520 + (3-n)*120, 0.07, 'sine');
      await sleep(900);
    }
    countdown.style.display='none';
    tPrev = performance.now();
    running = true;
    loop();
  }

  function end(){
    running = false;
    gameOver = true;
    finalLine.textContent = `Score: ${score}  •  Best: ${best}`;
    gameOverOverlay.style.display='flex';
    quickRetry.style.display='block';
    // store score history
    lastScores.push(score); if(lastScores.length>10) lastScores.shift();
    localStorage.setItem('two_thumb_last10', JSON.stringify(lastScores));
    drawSparkline();
  }

  function togglePause(forceOn){
    if(gameOver) return;
    const want = (forceOn===true) ? true : !paused;
    paused = want;
    if(paused){
      running=false;
      pauseOverlay.style.display='flex';
    }else{
      pauseOverlay.style.display='none';
      tPrev = performance.now();
      running=true;
      requestAnimationFrame(loop);
    }
  }

  // Particles
  function spawnSparks(x,y,color){
    const n = 8;
    for(let i=0;i<n;i++){
      particles.push({
        kind:'spark',
        x,y,
        vx:(Math.random()*2-1)*200,
        vy:(Math.random()*2-1)*200,
        life:140, // ms
        t:0,
        color
      });
    }
  }
  function spawnConfetti(x,y){
    for(let i=0;i<50;i++){
      particles.push({
        kind:'confetti',
        x, y,
        vx:(Math.random()*2-1)*140,
        vy:(Math.random()*-1)*220 - 80,
        g:420,
        size:2+Math.random()*3,
        rot:Math.random()*Math.PI,
        vr:(Math.random()*2-1)*6,
        life:1200,
        t:0,
        color:`hsl(${Math.floor(Math.random()*360)},90%,60%)`
      });
    }
  }

  // Physics + render
  let lastFrameAt = performance.now();
  function loop(now){
    if(!running) return;
    requestAnimationFrame(loop);
    now = now || performance.now();
    let dt = (now - tPrev)/1000;
    tPrev = now;
    if(dt>0.04) dt=0.04;

    // perf-based temporary reduce motion
    const frameMs = now - lastFrameAt; lastFrameAt = now;
    perfSkip = frameMs > 22;

    // Keyboard fallback small moves
    const step = Math.max(180, unit*0.3)*dt;
    if(keys['w']||keys['ArrowUp'])   leftY = clamp(leftY - step, paddleR, H-paddleR);
    if(keys['s']||keys['ArrowDown']) leftY = clamp(leftY + step, paddleR, H-paddleR);
    if(keys['i']) rightY = clamp(rightY - step, paddleR, H-paddleR);
    if(keys['k']) rightY = clamp(rightY + step, paddleR, H-paddleR);

    // Smooth speed ramp
    speed = lerp(speed, speedTarget, 0.5);

    // Move ball
    ballX += vx*dt; ballY += vy*dt;

    // Top/bottom bounce
    if(ballY - ballR <= 0){ ballY = ballR; vy = Math.abs(vy); ping(800); }
    if(ballY + ballR >= H){ ballY = H - ballR; vy = -Math.abs(vy); ping(800); }

    const leftX  = 16 + paddleR;
    const rightX = W - 16 - paddleR;

    // Approaching paddles -> danger cue and gentle auto-aim early
    let approachingLeft  = vx < 0 && (ballX - leftX) < unit*0.2;
    let approachingRight = vx > 0 && (rightX - ballX) < unit*0.2;
    let dangerLevel = 0;
    if(approachingLeft){
      const missMargin = Math.abs(ballY - leftY) - (paddleR + ballR)*0.9;
      dangerLevel = Math.max(0, Math.min(1, (missMargin)/(paddleR*0.4)));
      if(score<3 && missMargin>0){ vy += (leftY - ballY)*0.08; } // gentle help
    }
    if(approachingRight){
      const missMargin = Math.abs(ballY - rightY) - (paddleR + ballR)*0.9;
      dangerLevel = Math.max(dangerLevel, Math.max(0, Math.min(1, (missMargin)/(paddleR*0.4))));
      if(score<3 && missMargin>0){ vy += (rightY - ballY)*0.08; }
    }
    danger.style.opacity = dangerLevel>0 ? Math.min(0.6, dangerLevel) : 0;

    // Paddle collisions
    if(vx < 0 && ballX - ballR <= leftX + paddleR){
      const dy = Math.abs(ballY - leftY);
      if(dy <= paddleR + ballR){
        const offset = (ballY - leftY) / (paddleR + ballR);
        const ang = offset * 0.9;
        const newTarget = Math.min(speedTarget*1.035, speedMax);
        speedTarget = newTarget;
        const cs = Math.cos(ang), sn = Math.sin(ang);
        vx = Math.abs(speed) * cs; // reflect to right
        vy = speed * sn;
        ballX = leftX + paddleR + ballR + 0.1;
        onRally('L', leftX, leftY);
      } else if(ballX + ballR < 0){
        onMiss();
        return;
      }
    }
    if(vx > 0 && ballX + ballR >= rightX - paddleR){
      const dy = Math.abs(ballY - rightY);
      if(dy <= paddleR + ballR){
        const offset = (ballY - rightY) / (paddleR + ballR);
        const ang = offset * 0.9;
        const newTarget = Math.min(speedTarget*1.035, speedMax);
        speedTarget = newTarget;
        const cs = Math.cos(ang), sn = Math.sin(ang);
        vx = -Math.abs(speed) * cs; // reflect to left
        vy = speed * sn;
        ballX = rightX - paddleR - ballR - 0.1;
        onRally('R', rightX, rightY);
      } else if(ballX - ballR > W){
        onMiss();
        return;
      }
    }

    // Draw
    ctx.clearRect(0,0,W,H);

    // screenshake
    if((!reduceMotion && !perfSkip) && shakeT>0){
      const mag = 3; // px
      const t = Math.min(120, shakeT)/120;
      ctx.save();
      ctx.translate((Math.random()*2-1)*mag*t, (Math.random()*2-1)*mag*t);
      drawScene(leftX,rightX);
      ctx.restore();
      shakeT -= (dt*1000);
    } else {
      drawScene(leftX,rightX);
    }

    // Particles
    drawParticles(dt);
  }

  function drawScene(leftX,rightX){
    // Center dashed net
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--net').trim();
    ctx.lineWidth = 2;
    ctx.setLineDash([10,10]);
    ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.restore();

    drawPuck(leftX, leftY, paddleR, getComputedStyle(document.body).getPropertyValue('--puck').trim());
    drawPuck(rightX, rightY, paddleR, getComputedStyle(document.body).getPropertyValue('--puck').trim());

    // Ball trail
    if(!(reduceMotion || perfSkip)){
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,.07)';
      for(let i=1;i<=5;i++){
        const bx = ballX - vx*(i*0.008);
        const by = ballY - vy*(i*0.008);
        ctx.beginPath(); ctx.arc(bx,by,ballR*(1-i*0.12),0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    // Ball
    ctx.save();
    const grd = ctx.createRadialGradient(ballX-ballR*0.4, ballY-ballR*0.4, ballR*0.2, ballX, ballY, ballR);
    grd.addColorStop(0,'#fff'); grd.addColorStop(1,'#d5e9ff');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(ballX, ballY, ballR, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawPuck(x,y,r,color){
    if(!(reduceMotion || perfSkip)){
      ctx.save(); ctx.shadowColor = color; ctx.shadowBlur = 16; ctx.globalAlpha = 0.9;
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
    }else{
      ctx.save(); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
    ctx.save(); ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--rim').trim(); ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke(); ctx.restore();
  }

  function drawParticles(dt){
    if(particles.length===0) return;
    const rm = (reduceMotion || perfSkip);
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt*1000;
      if(p.t > p.life){ particles.splice(i,1); continue; }
      if(p.kind==='spark'){
        if(rm) continue; // skip sparks if reduce motion
        const a = 1 - (p.t/p.life);
        ctx.save();
        ctx.globalAlpha = a;
        ctx.strokeStyle = p.color || '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + p.vx*0.08, p.y + p.vy*0.08);
        ctx.stroke();
        ctx.restore();
        // move
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.vx *= 0.92; p.vy *= 0.92;
      } else if(p.kind==='confetti'){
        if(rm) continue;
        p.vy += p.g*dt;
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.rot += p.vr*dt;
        const a = 1 - (p.t/p.life);
        ctx.save();
        ctx.globalAlpha = Math.max(0,a);
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size);
        ctx.restore();
      }
    }
  }

  function onRally(side, px, py){
    score++; scoreEl.textContent = String(score);
    runRalliesEl.textContent = String(score);
    if(score>best){
      // celebrate before saving
      showToast();
      spawnConfetti(W/2, H*0.3);
      best = score;
      bestEl.textContent = String(best);
      localStorage.setItem('two_thumb_best', best);
    }
    if(score>longest){ longest=score; longestEl.textContent = String(longest); localStorage.setItem('two_thumb_longest', longest); }
    // feedback
    spawnSparks(px + (side==='L'? paddleR: -paddleR), py, '#fff');
    if(side==='L'){ vibrate([12]); } else { vibrate([6,6,6]); }
    ping(1200);
  }

  function onMiss(){
    vibrate([50]);
    ping(220,0.12,'triangle');
    shakeT = 120;
    end();
  }

  function showToast(){
    toast.style.display='block';
    toast.style.opacity='1';
    setTimeout(()=>{ toast.style.opacity='0'; }, 900);
    setTimeout(()=>{ toast.style.display='none'; }, 1400);
  }

  // Visibility pause
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){ running=false; }
    else if(!gameOver && startOverlay.style.display==='none' && !paused){ tPrev=performance.now(); running=true; requestAnimationFrame(loop); }
  });

  // Buttons
  startBtn.addEventListener('click', begin);
  restartBtn.addEventListener('click', begin);
  quickBtn.addEventListener('click', begin);
  resumeBtn.addEventListener('click', ()=>togglePause(false));
  shareBtn.addEventListener('click', async ()=>{
    const text = `I scored ${score} in Two-Thumb Pong!`;
    const data = {title:'Two-Thumb Pong', text};
    try{
      if(navigator.share){ await navigator.share(data); }
      else {
        await navigator.clipboard.writeText(text);
        shareBtn.textContent='Copied';
        setTimeout(()=>shareBtn.textContent='Share',1200);
      }
    }catch{}
  });

  // Settings toggles
  function syncButtons(){
    muteBtn.textContent = 'Sound: ' + (muted ? 'Off' : 'On');
    muteBtn.setAttribute('aria-pressed', String(!muted));
    contrastBtn.textContent = 'High Contrast: ' + (highContrast? 'On':'Off');
    contrastBtn.setAttribute('aria-pressed', String(highContrast));
    motionBtn.textContent = 'Reduce Motion: ' + (reduceMotion? 'On':'Off');
    motionBtn.setAttribute('aria-pressed', String(reduceMotion));
  }
  function applyTheme(){
    if(highContrast) document.body.classList.add('contrast');
    else document.body.classList.remove('contrast');
  }
  function fsWanted(){
    return (localStorage.getItem('two_thumb_fullscreen')||'0')==='1';
  }
  function setFsWanted(v){
    localStorage.setItem('two_thumb_fullscreen', v?'1':'0');
    fsBtn.textContent = v ? 'Fullscreen: On' : 'Fullscreen: Try';
  }
  muteBtn.addEventListener('click', ()=>{
    muted = !muted; localStorage.setItem('two_thumb_muted', muted?'1':'0'); syncButtons(); if(!muted) ping(880,0.05);
  });
  contrastBtn.addEventListener('click', ()=>{
    highContrast = !highContrast; localStorage.setItem('two_thumb_contrast', highContrast?'1':'0'); applyTheme(); syncButtons();
  });
  motionBtn.addEventListener('click', ()=>{
    reduceMotion = !reduceMotion; localStorage.setItem('two_thumb_motion', reduceMotion?'1':'0'); syncButtons();
  });
  fsBtn.addEventListener('click', async ()=>{
    const want = !fsWanted();
    setFsWanted(want);
    if(want && !document.fullscreenElement){
      try{ await document.documentElement.requestFullscreen(); }catch{}
    }else if(!want && document.fullscreenElement){
      try{ await document.exitFullscreen(); }catch{}
    }
  });
  // init UI
  applyTheme(); syncButtons(); setFsWanted(fsWanted());

  // Tap canvas to begin from splash
  canvas.addEventListener('click', ()=>{
    if(startOverlay.style.display!=='none' && !running){ begin(); }
  });

  // Initial splash draw
  (function drawSplash(){
    ctx.clearRect(0,0,W,H);
    const leftX  = 16 + Math.max(24, unit*0.065);
    const rightX = W - 16 - Math.max(24, unit*0.065);
    drawPuck(leftX, H*0.5, Math.max(24, unit*0.065), getComputedStyle(document.body).getPropertyValue('--puck').trim());
    drawPuck(rightX,H*0.5, Math.max(24, unit*0.065), getComputedStyle(document.body).getPropertyValue('--puck').trim());
    const x=W*0.5, y=H*0.5, r=Math.max(10, unit*0.018);
    ctx.fillStyle='#eaf6ff'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    // thumb labels will auto-fade
    setTimeout(()=>{ lblLeft.style.opacity=0; lblRight.style.opacity=0; }, 1500);
  })();

  // Sparkline
  function drawSparkline(){
    sctx.clearRect(0,0,sparkline.width,sparkline.height);
    const w = sparkline.clientWidth, h = sparkline.clientHeight;
    sctx.fillStyle = 'rgba(255,255,255,.08)';
    sctx.fillRect(0,0,w,h);
    const data = lastScores.slice(-10);
    if(data.length===0) return;
    const max = Math.max(...data, 1);
    const barW = Math.max(3, Math.floor((w-8)/data.length)-2);
    data.forEach((v,i)=>{
      const bh = Math.max(2, Math.round((v/max)*(h-6)));
      const x = 4 + i*(barW+2);
      const y = h - 3 - bh;
      sctx.fillStyle = 'rgba(255,255,255,.9)';
      sctx.fillRect(x,y,barW,bh);
    });
    avgEl.textContent = avgFromLast(data).toFixed(0);
  }
})();
</script>
</body>
</html>
