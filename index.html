<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Two-Thumb Pong (Solo)</title>
<style>
  :root{
    --bg1:#0f1222; --bg2:#1a2040; --fg:#e6e8ef; --muted:#9aa3b2; --accent:#58d3ff; --good:#35e06f; --bad:#ff5d73;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--fg);overflow:hidden}
  #wrap{position:fixed;inset:0; padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
  #hud{position:fixed;left:0;right:0;top:0;padding:calc(8px + env(safe-area-inset-top)) 12px 8px;display:flex;justify-content:space-between;align-items:center;pointer-events:none}
  #score{font-weight:700;font-size:20px;letter-spacing:.5px}
  #best{font-size:12px;color:var(--muted)}
  #canvas{display:block;width:100%;height:100%}
  /* touch zones hint */
  .zone{position:fixed;top:0;bottom:0;width:50vw;opacity:.08;pointer-events:none}
  .zone.left{left:0;background:radial-gradient(120vw 120vh at 0% 50%,#fff,transparent)}
  .zone.right{right:0;background:radial-gradient(120vw 120vh at 100% 50%,#fff,transparent)}
  /* overlays */
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(5,7,15,.6);backdrop-filter:blur(4px)}
  .card{width:min(92vw,520px);background:#0e1225;border:1px solid #222a4e;border-radius:16px;box-shadow:0 10px 30px #0007;padding:20px;text-align:center}
  .card h1{margin:0 0 6px;font-size:22px}
  .card p{margin:6px 0 14px;color:var(--muted);line-height:1.4}
  .btn{display:inline-block;border:0;border-radius:14px;padding:14px 18px;font-weight:700;cursor:pointer}
  .btn.primary{background:var(--accent);color:#020611}
  .btn.ghost{background:transparent;color:var(--fg);border:1px solid #2c355f}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .stats{display:flex;gap:16px;justify-content:center;margin-top:10px;color:var(--muted);font-size:13px}
  /* bottom helper */
  #tip{position:fixed;left:0;right:0;bottom:calc(8px + env(safe-area-inset-bottom));text-align:center;color:var(--muted);font-size:12px;pointer-events:none}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="hud">
    <div id="score">0</div>
    <div id="best">Best: <span id="bestVal">0</span></div>
  </div>
  <div class="zone left" aria-hidden="true"></div>
  <div class="zone right" aria-hidden="true"></div>
  <div id="tip">Use both thumbs. Touch left/right halves to move each puck.</div>

  <div id="startOverlay" class="overlay">
    <div class="card">
      <h1>Two-Thumb Pong</h1>
      <p>Keep the ball bouncing between your left and right pucks. If it slips past either side, the run ends.</p>
      <div class="stats"><span>Drag anywhere on each half</span><span>Speed ramps up</span></div>
      <div class="row" style="margin-top:12px">
        <button id="startBtn" class="btn primary">Start</button>
        <button id="muteBtn" class="btn ghost" aria-pressed="false">Sound: Off</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay" class="overlay" style="display:none">
    <div class="card">
      <h1>Game Over</h1>
      <p id="finalLine">Score: 0</p>
      <div class="row">
        <button id="restartBtn" class="btn primary">Restart</button>
        <button id="shareBtn" class="btn ghost">Share</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('bestVal');
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalLine = document.getElementById('finalLine');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const shareBtn = document.getElementById('shareBtn');
  const muteBtn = document.getElementById('muteBtn');

  // State
  let W=0, H=0, DPR=1, unit=0;
  let running=false, gameOver=false, tPrev=0;
  let leftY=0, rightY=0, paddleR=0, ballR=0;
  let ballX=0, ballY=0, vx=0, vy=0, speed=0, speedMax=0;
  let score=0, best=Number(localStorage.getItem('two_thumb_best')||0);
  let muted=true;

  bestEl.textContent = best;

  // Audio (lightweight)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx = null;
  function ping(freq, dur=0.06, type='sine'){
    if(muted) return;
    actx = actx || new AudioCtx();
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type;
    o.frequency.value = freq;
    o.connect(g); g.connect(actx.destination);
    g.gain.value = 0.15;
    o.start();
    setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime + dur); }, 0);
    setTimeout(()=>{ o.stop(); }, dur*1000+20);
  }

  function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  // Resize
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    canvas.width = Math.floor(cssW * DPR);
    canvas.height = Math.floor(cssH * DPR);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    W = cssW; H = cssH; unit = Math.min(W,H);
    paddleR = Math.max(24, unit*0.065);
    ballR   = Math.max(10, unit*0.018);
    // maintain paddle positions relative
    leftY = leftY? Math.max(paddleR, Math.min(H-paddleR, leftY)) : H/2;
    rightY= rightY? Math.max(paddleR, Math.min(H-paddleR, rightY)) : H/2;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Helpers
  function clamp(v,min,max){ return v<min?min:v>max?max:v; }

  // Controls (multi-touch)
  const touchSide = new Map(); // id -> 'L' | 'R'
  function handleTouches(list){
    for(let i=0;i<list.length;i++){
      const t = list[i];
      const x = t.clientX, y = t.clientY;
      const side = (x < W/2) ? 'L' : 'R';
      touchSide.set(t.identifier, side);
      if(side==='L'){ leftY = clamp(y, paddleR, H-paddleR); }
      else { rightY = clamp(y, paddleR, H-paddleR); }
    }
  }
  function moveTouches(list){
    for(let i=0;i<list.length;i++){
      const t = list[i];
      const side = touchSide.get(t.identifier) || ((t.clientX<W/2)?'L':'R');
      if(side==='L'){ leftY = clamp(t.clientY, paddleR, H-paddleR); }
      else { rightY = clamp(t.clientY, paddleR, H-paddleR); }
    }
  }
  function endTouches(list){
    for(let i=0;i<list.length;i++){ touchSide.delete(list[i].identifier); }
  }
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouches(e.changedTouches); }, {passive:false});
  canvas.addEventListener('touchmove',  (e)=>{ e.preventDefault(); moveTouches(e.changedTouches); },   {passive:false});
  canvas.addEventListener('touchend',   (e)=>{ e.preventDefault(); endTouches(e.changedTouches); },    {passive:false});
  canvas.addEventListener('touchcancel',(e)=>{ e.preventDefault(); endTouches(e.changedTouches); },    {passive:false});

  // Desktop fallback (mouse + arrows/WASD)
  let mouseDown=false;
  canvas.addEventListener('mousedown', e=>{ mouseDown=true; (e.clientX<W/2? leftY=clamp(e.clientY,paddleR,H-paddleR): rightY=clamp(e.clientY,paddleR,H-paddleR)); });
  window.addEventListener('mouseup', ()=>mouseDown=false);
  window.addEventListener('mousemove', e=>{ if(!mouseDown) return; (e.clientX<W/2? leftY=clamp(e.clientY,paddleR,H-paddleR): rightY=clamp(e.clientY,paddleR,H-paddleR)); });
  const keys = {};
  window.addEventListener('keydown',e=>{ keys[e.key]=true; });
  window.addEventListener('keyup',e=>{ keys[e.key]=false; });

  // Game init
  function serve(){
    score = 0;
    scoreEl.textContent = '0';
    leftY = H*0.5; rightY = H*0.5;
    const dir = Math.random()<0.5? -1: 1; // start moving left or right
    ballX = W*0.5 + dir*unit*0.05;
    ballY = H*0.5;
    const angle = (Math.random()*0.6 - 0.3); // slight vertical component
    speed = Math.max(220, unit*0.36);
    speedMax = Math.max(600, unit*0.9);
    vx = dir * speed * Math.cos(angle);
    vy = speed * Math.sin(angle);
    gameOver = false;
  }

  function start(){
    serve();
    running = true;
    tPrev = performance.now();
    startOverlay.style.display='none';
    gameOverOverlay.style.display='none';
    loop();
  }

  function end(){
    running = false;
    gameOver = true;
    finalLine.textContent = `Score: ${score}  â€¢  Best: ${best}`;
    gameOverOverlay.style.display='flex';
  }

  // Physics + render
  function loop(now){
    if(!running) return;
    requestAnimationFrame(loop);
    now = now || performance.now();
    let dt = (now - tPrev)/1000;
    tPrev = now;
    // cap dt to avoid big jumps
    if(dt>0.04) dt=0.04;

    // Keyboard fallback small moves
    const step = Math.max(180, unit*0.3)*dt;
    if(keys['w']||keys['ArrowUp'])   leftY = clamp(leftY - step, paddleR, H-paddleR);
    if(keys['s']||keys['ArrowDown']) leftY = clamp(leftY + step, paddleR, H-paddleR);
    if(keys['i']) rightY = clamp(rightY - step, paddleR, H-paddleR);
    if(keys['k']) rightY = clamp(rightY + step, paddleR, H-paddleR);

    // Move ball
    ballX += vx*dt; ballY += vy*dt;

    // Top/bottom bounce
    if(ballY - ballR <= 0){ ballY = ballR; vy = Math.abs(vy); ping(800); }
    if(ballY + ballR >= H){ ballY = H - ballR; vy = -Math.abs(vy); ping(800); }

    const leftX  = 16 + paddleR;           // puck center x
    const rightX = W - 16 - paddleR;

    // Paddle collisions
    // Left side crossing
    if(vx < 0 && ballX - ballR <= leftX + paddleR){
      const dy = Math.abs(ballY - leftY);
      if(dy <= paddleR + ballR){
        // reflect and add spin based on offset
        const offset = (ballY - leftY) / (paddleR + ballR);
        const angAdj = offset * 0.9;
        const sp = Math.min(speed*1.035, speedMax);
        speed = sp;
        const dir = 1;
        const angle = angAdj;
        const cs = Math.cos(angle), sn = Math.sin(angle);
        vx = dir * sp * cs;
        vy = sp * sn;
        ballX = leftX + paddleR + ballR + 0.1;
        score++; scoreEl.textContent = String(score);
        if(score>best){ best = score; bestEl.textContent = String(best); localStorage.setItem('two_thumb_best', best); }
        ping(1200); vibrate(10);
      } else if(ballX + ballR < 0){
        vibrate(40); ping(220,0.12,'triangle'); end();
      }
    }
    // Right side crossing
    if(vx > 0 && ballX + ballR >= rightX - paddleR){
      const dy = Math.abs(ballY - rightY);
      if(dy <= paddleR + ballR){
        const offset = (ballY - rightY) / (paddleR + ballR);
        const angAdj = offset * 0.9;
        const sp = Math.min(speed*1.035, speedMax);
        speed = sp;
        const dir = -1;
        const angle = angAdj;
        const cs = Math.cos(angle), sn = Math.sin(angle);
        vx = dir * sp * cs;
        vy = sp * sn;
        ballX = rightX - paddleR - ballR - 0.1;
        score++; scoreEl.textContent = String(score);
        if(score>best){ best = score; bestEl.textContent = String(best); localStorage.setItem('two_thumb_best', best); }
        ping(1200); vibrate(10);
      } else if(ballX - ballR > W){
        vibrate(40); ping(220,0.12,'triangle'); end();
      }
    }

    // Draw
    ctx.clearRect(0,0,W,H);

    // Center dashed net
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = 2;
    ctx.setLineDash([10,10]);
    ctx.beginPath();
    ctx.moveTo(W/2, 0);
    ctx.lineTo(W/2, H);
    ctx.stroke();
    ctx.restore();

    // Pucks
    drawPuck(leftX, leftY, paddleR, '#7ae0ff');
    drawPuck(rightX, rightY, paddleR, '#7ae0ff');

    // Ball trail
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,.07)';
    for(let i=1;i<=5;i++){
      const bx = ballX - vx*(i*0.008);
      const by = ballY - vy*(i*0.008);
      ctx.beginPath(); ctx.arc(bx,by,ballR*(1-i*0.12),0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // Ball
    ctx.save();
    const grd = ctx.createRadialGradient(ballX-ballR*0.4, ballY-ballR*0.4, ballR*0.2, ballX, ballY, ballR);
    grd.addColorStop(0,'#fff'); grd.addColorStop(1,'#d5e9ff');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(ballX, ballY, ballR, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawPuck(x,y,r,color){
    ctx.save();
    // glow
    ctx.shadowColor = color; ctx.shadowBlur = 16; ctx.globalAlpha = 0.85;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
    // rim
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke(); ctx.restore();
  }

  // Visibility pause
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){ running=false; }
    else if(!gameOver && startOverlay.style.display==='none'){ tPrev=performance.now(); running=true; requestAnimationFrame(loop); }
  });

  // Buttons
  startBtn.addEventListener('click', start);
  restartBtn.addEventListener('click', ()=>{ start(); });
  shareBtn.addEventListener('click', async ()=>{
    const text = `I scored ${score} in Two-Thumb Pong!`;
    const data = {title:'Two-Thumb Pong', text};
    try{
      if(navigator.share){ await navigator.share(data); }
      else {
        await navigator.clipboard.writeText(text);
        shareBtn.textContent='Copied';
        setTimeout(()=>shareBtn.textContent='Share',1200);
      }
    }catch{}
  });
  muteBtn.addEventListener('click', ()=>{
    muted = !muted;
    muteBtn.textContent = 'Sound: ' + (muted ? 'Off' : 'On');
    muteBtn.setAttribute('aria-pressed', String(!muted));
    if(!muted) ping(880,0.05);
  });

  // Auto-start with a short countdown if user taps canvas
  canvas.addEventListener('click', ()=>{
    if(startOverlay.style.display!=='none' && !running){
      start();
    }
  });

  // Initial paint
  (function drawSplash(){
    ctx.clearRect(0,0,W,H);
    // center pucks
    const leftX  = 16 + Math.max(24, unit*0.065);
    const rightX = W - 16 - Math.max(24, unit*0.065);
    drawPuck(leftX, H*0.5, Math.max(24, unit*0.065), '#7ae0ff');
    drawPuck(rightX,H*0.5, Math.max(24, unit*0.065), '#7ae0ff');
    // ball
    const x=W*0.5, y=H*0.5, r=Math.max(10, unit*0.018);
    ctx.fillStyle='#eaf6ff'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  })();

})();
</script>
</body>
</html>
