<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Dual-Thumb Pong</title>
<style>
  :root{
    --bg:#0b0f14;
    --fg:#ffffff;
    --muted:#9aa4ad;
    --accent:#00e0ff;
    --accent2:#7cff6b;
    --danger:#ff4d4d;
    --hud:rgba(0,0,0,0.35);
    --btn:rgba(255,255,255,0.1);
    --btnActive:rgba(255,255,255,0.18);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#0b0f14,#061016 65%,#05121b);}
  body{
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    color:var(--fg);
    overflow:hidden;
    touch-action:none;
  }
  /* Layout */
  .app{
    position:fixed; inset:0;
    padding-top:calc(env(safe-area-inset-top) + 8px);
    padding-bottom:calc(env(safe-area-inset-bottom) + 8px);
    padding-left:calc(env(safe-area-inset-left) + 8px);
    padding-right:calc(env(safe-area-inset-right) + 8px);
  }
  #game{
    position:absolute; inset:0;
    width:100svw; height:100svh; /* modern */
  }
  /* HUD */
  .hud{
    position:absolute; left:0; right:0; top:0; pointer-events:none;
    display:flex; justify-content:center; align-items:flex-start;
    padding:10px;
  }
  .hud-bar{
    display:flex; gap:10px; align-items:center; pointer-events:auto;
    background:var(--hud); backdrop-filter:blur(6px);
    border:1px solid rgba(255,255,255,0.15);
    border-radius:14px; padding:8px 10px;
  }
  .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.08); font-weight:600; font-variant-numeric:tabular-nums;}
  .pill small{color:var(--muted); font-weight:600; margin-right:6px; text-transform:uppercase; letter-spacing:.04em; font-size:.7rem;}
  .hearts{letter-spacing:2px; min-width:74px; text-align:center;}
  .btn{
    appearance:none; border:0; border-radius:10px; padding:10px 12px;
    background:var(--btn); color:var(--fg); font-weight:700;
    min-width:44px; min-height:44px; cursor:pointer;
  }
  .btn:active{background:var(--btnActive);}
  .icon{font-size:18px; line-height:0;}
  /* Overlays */
  .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.55); backdrop-filter: blur(8px);
    padding:20px;
    opacity:0; pointer-events:none; transition:opacity .2s;
  }
  .overlay.show{opacity:1; pointer-events:auto;}
  .card{
    width:min(560px, 92vw); background:rgba(9,12,17,0.9);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:16px; padding:18px;
  }
  .card h1{margin:4px 0 8px; font-size:1.25rem;}
  .card p{margin:8px 0; color:#c6d0d8; line-height:1.35;}
  .row{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}
  .row .btn{flex:1}
  .muted{color:var(--muted); font-size:.9rem}
  .kbd{display:inline-block; padding:2px 8px; border-radius:6px; background:#111820; border:1px solid #243141; font-weight:700;}
  /* Countdown */
  .count{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    font-size:18vmin; font-weight:900; color:#fff; text-shadow:0 6px 22px rgba(0,0,0,.55);
    opacity:0; transform:scale(.9); transition:opacity .18s, transform .18s;
    pointer-events:none;
  }
  .count.show{opacity:1; transform:scale(1);}
  /* Touch hint zones (subtle) */
  .zones{
    position:absolute; inset:0; display:flex; pointer-events:none;
  }
  .zones div{
    flex:1; border-left:1px dashed rgba(255,255,255,0.06);
    border-right:1px dashed rgba(255,255,255,0.06);
    background:linear-gradient(0deg, rgba(255,255,255,0.03), transparent 40% 60%, rgba(255,255,255,0.03));
    opacity:.0;
  }
  .zones.show div{opacity:.35; animation:fadeZone 1.1s ease-in-out infinite alternate;}
  @keyframes fadeZone{from{opacity:.16} to{opacity:.33}}
  /* Footer helper for rotate prompt */
  .foot{
    position:absolute; bottom:8px; left:0; right:0; text-align:center; color:var(--muted); font-size:.8rem;
    pointer-events:none;
  }
</style>
</head>
<body>
<div class="app">
  <canvas id="game" aria-label="Dual-Thumb Pong"></canvas>

  <!-- Subtle training zones (auto-hide after first hit) -->
  <div class="zones" id="zones"><div></div><div></div></div>

  <!-- HUD -->
  <div class="hud">
    <div class="hud-bar">
      <div class="pill"><small>Score</small><span id="score">0</span></div>
      <div class="pill"><small>Best</small><span id="best">0</span></div>
      <div class="pill hearts" id="lives" aria-label="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <button class="btn" id="pauseBtn" aria-label="Pause / Resume"><span class="icon" id="pauseIcon">‚è∏Ô∏è</span></button>
      <button class="btn" id="muteBtn" aria-label="Sound"><span class="icon" id="muteIcon">üîä</span></button>
    </div>
  </div>

  <!-- Start / Game Over Overlay -->
  <div class="overlay show" id="startOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>Dual-Thumb Pong</h1>
      <p>Use both thumbs. Drag on each half of the screen to move the paddles. Keep the ball alive. You have <b>3 lives</b>. Speed ramps up.</p>
      <ul class="muted" style="margin:8px 0 2px; padding-left:18px;">
        <li>Left thumb controls the <span style="color:var(--accent2); font-weight:700;">left</span> paddle.</li>
        <li>Right thumb controls the <span style="color:var(--accent); font-weight:700;">right</span> paddle.</li>
        <li>Tap <span class="kbd">‚è∏Ô∏è</span> to pause. Tap <span class="kbd">üîä</span> to mute.</li>
      </ul>
      <div class="row">
        <button class="btn" id="startBtn" style="background:linear-gradient(90deg,var(--accent2),var(--accent)); color:#001015; font-weight:900;">Start</button>
        <button class="btn" id="howBtn">How to play</button>
      </div>
      <p class="foot">Best played in portrait. Works in landscape.</p>
    </div>
  </div>

  <!-- Pause Overlay -->
  <div class="overlay" id="pauseOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>Paused</h1>
      <p class="muted">Drag to move paddles when you resume.</p>
      <div class="row">
        <button class="btn" id="resumeBtn" style="background:var(--btnActive);">Resume</button>
        <button class="btn" id="restartBtn">Restart</button>
      </div>
    </div>
  </div>

  <!-- How-To Overlay -->
  <div class="overlay" id="howOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>How to play</h1>
      <p>Keep the ball bouncing between paddles. Angle the ball by hitting it off-center on a paddle. The ball speeds up on each hit.</p>
      <p class="muted">Tips: keep thumbs near screen edges. Watch the carom angle. Don‚Äôt chase late‚Äîmeet the ball early.</p>
      <div class="row">
        <button class="btn" id="closeHow">Got it</button>
      </div>
    </div>
  </div>

  <!-- Countdown -->
  <div id="count" class="count">3</div>
</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:false });

  // UI
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const livesEl = document.getElementById('lives');
  const pauseBtn= document.getElementById('pauseBtn');
  const pauseIcon= document.getElementById('pauseIcon');
  const muteBtn = document.getElementById('muteBtn');
  const muteIcon= document.getElementById('muteIcon');

  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const howOverlay   = document.getElementById('howOverlay');
  const startBtn     = document.getElementById('startBtn');
  const howBtn       = document.getElementById('howBtn');
  const closeHow     = document.getElementById('closeHow');
  const resumeBtn    = document.getElementById('resumeBtn');
  const restartBtn   = document.getElementById('restartBtn');
  const zones        = document.getElementById('zones');
  const countEl      = document.getElementById('count');

  const storageBestKey = 'dual_thumb_pong_best_v1';
  let best = Number(localStorage.getItem(storageBestKey) || 0);
  bestEl.textContent = best;

  // Sizing
  let W=0, H=0, DPR=1;
  function resize(){
    const dpr = Math.min(devicePixelRatio || 1, 2);
    DPR = dpr;
    // Use small viewport units to avoid iOS URL bar issues
    const cssW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const cssH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    canvas.style.width = cssW + 'px';
    canvas.style.height= cssH + 'px';
    W = canvas.width; H = canvas.height;
    // Rebound paddles into view
    left.y  = clamp(left.y, padMargin, H - padMargin);
    right.y = clamp(right.y, padMargin, H - padMargin);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // Game objects
  const padRadiusBase = 28; // CSS pixels baseline, scaled by DPR later
  let padR = padRadiusBase * DPR;
  let padMargin = 60 * DPR; // top/bottom bounds
  let wall = { top: 0 + padMargin/2, bottom: () => H - padMargin/2 };

  const left  = { x: () => (22 * DPR), y: H/2, r: () => padR, color: '#7cff6b' };
  const right = { x: () => (W - 22 * DPR), y: H/2, r: () => padR, color: '#00e0ff' };

  const ball = {
    x: W/2, y: H/2, r: 10*DPR,
    vx: 240, vy: 60,
    speed: 260, // px/s
    maxSpeed: 1100,
  };

  let score=0, lives=3, running=false, paused=false, countdown=false, firstHit=false;
  updateHUD();

  // Touch handling
  const touches = new Map(); // id -> { side: 'L'|'R' }
  let showZones = true;
  function sideFor(xCss){
    const mid = canvas.clientWidth / 2;
    return xCss < mid ? 'L' : 'R';
  }
  function cssToCanvasY(yCss){ return yCss * DPR; }

  function setPaddle(side, yCanvas){
    const boundsTop = padMargin, boundsBottom = H - padMargin;
    const clamped = clamp(yCanvas, boundsTop, boundsBottom);
    if(side==='L') left.y = clamped;
    else right.y = clamped;
  }

  canvas.addEventListener('touchstart', (e)=>{
    for(const t of e.changedTouches){
      const s = sideFor(t.clientX);
      touches.set(t.identifier, { side:s });
      setPaddle(s, cssToCanvasY(t.clientY));
    }
    e.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchmove', (e)=>{
    for(const t of e.changedTouches){
      const data = touches.get(t.identifier);
      if(!data) continue;
      setPaddle(data.side, cssToCanvasY(t.clientY));
    }
    e.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchend', (e)=>{
    for(const t of e.changedTouches){ touches.delete(t.identifier); }
    e.preventDefault();
  }, { passive:false });

  // Pointer fallback (mouse/pen)
  let activePointer = null;
  canvas.addEventListener('pointerdown', (e)=>{
    activePointer = sideFor(e.clientX);
    setPaddle(activePointer, cssToCanvasY(e.clientY));
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!activePointer) return;
    setPaddle(activePointer, cssToCanvasY(e.clientY));
  });
  canvas.addEventListener('pointerup', ()=>{ activePointer=null; });

  // Audio (WebAudio tiny beeps)
  let audio = { ctx:null, muted:false };
  function ensureAudio(){
    if(audio.ctx) return;
    try{
      audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }catch(e){ /* ignore */ }
  }
  function beep(freq=440, dur=0.05, type='sine', vol=0.03){
    if(audio.muted || !audio.ctx) return;
    const ctx = audio.ctx;
    const t0 = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type; o.frequency.value=freq;
    g.gain.value = vol; g.gain.setTargetAtTime(0.0001, t0+dur*0.55, 0.03);
    o.connect(g).connect(ctx.destination);
    o.start(t0);
    o.stop(t0 + Math.max(0.03, dur));
  }
  function hitSound(){ beep(520, 0.05, 'triangle', 0.035); }
  function wallSound(){ beep(280, 0.04, 'sine', 0.02); }
  function missSound(){ beep(140, 0.18, 'square', 0.05); }

  // Haptics
  function vibe(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  // Controls
  pauseBtn.addEventListener('click', ()=>{
    if(!running) return;
    if(paused){ resume(); } else { pause(); }
  });
  muteBtn.addEventListener('click', ()=>{
    audio.muted = !audio.muted;
    ensureAudio();
    muteIcon.textContent = audio.muted ? 'üîá' : 'üîä';
  });

  startBtn.addEventListener('click', ()=>{
    ensureAudio();
    startOverlay.classList.remove('show');
    startGameWithCountdown();
  });
  howBtn.addEventListener('click', ()=> howOverlay.classList.add('show'));
  closeHow.addEventListener('click', ()=> howOverlay.classList.remove('show'));
  resumeBtn.addEventListener('click', ()=> resume());
  restartBtn.addEventListener('click', ()=> { pauseOverlay.classList.remove('show'); fullRestart(); });

  function startGameWithCountdown(){
    if(running){ fullRestart(); return; }
    score=0; lives=3; firstHit=false; updateHUD();
    resetBall(Math.random()<0.5?'L':'R', true);
    countdownGo(()=>{ running=true; paused=false; showZones = true; zones.classList.add('show'); });
  }
  function pause(){
    if(!running) return;
    paused=true; pauseIcon.textContent='‚ñ∂Ô∏è'; pauseOverlay.classList.add('show');
  }
  function resume(){
    if(!running) return;
    paused=false; pauseIcon.textContent='‚è∏Ô∏è'; pauseOverlay.classList.remove('show');
    // quick 3-2-1 to reorient
    countdownGo(()=>{});
  }
  function fullRestart(){
    running=false; paused=false;
    score=0; lives=3; updateHUD();
    resetBall(Math.random()<0.5?'L':'R', true);
    countdownGo(()=>{ running=true; paused=false; showZones=true; zones.classList.add('show'); });
  }

  function updateHUD(){
    scoreEl.textContent = score;
    bestEl.textContent = best;
    livesEl.textContent = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);
  }

  function resetBall(towardsSide='R', fresh=false){
    ball.x = W/2; ball.y = H/2;
    const angle = (Math.random()*0.6 - 0.3); // -0.3..0.3 rad vertical tilt
    ball.speed = fresh ? 280*DPR : Math.max(260*DPR, Math.min(ball.speed*0.9, 520*DPR));
    const dir = towardsSide === 'R' ? 1 : -1;
    ball.vx = Math.cos(angle) * ball.speed * dir;
    ball.vy = Math.sin(angle) * ball.speed;
  }

  function countdownGo(done){
    countdown=true;
    let n=3;
    countEl.textContent = n; countEl.classList.add('show');
    const timer = setInterval(()=>{
      n--; if(n>0){ countEl.textContent = n; } else {
        clearInterval(timer);
        countEl.classList.remove('show');
        countdown=false;
        if(typeof done==='function') done();
      }
    }, 700);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // Collision
  function collidePaddle(p){
    const dx = Math.abs(ball.x - p.x());
    const dy = Math.abs(ball.y - p.y);
    const dist = Math.hypot(dx, dy);
    // Treat paddles as circles
    if(dist <= ball.r + p.r()){
      // Compute reflection with angle control by impact offset
      const offset = clamp((ball.y - p.y) / p.r(), -1, 1);
      const maxAngle = 1.05; // ~60 degrees
      const angle = offset * maxAngle;
      // Increase speed
      ball.speed = Math.min(ball.speed * 1.06, ball.maxSpeed * DPR);
      const dir = (p === left) ? 1 : -1;
      ball.vx = Math.cos(angle) * ball.speed * dir;
      ball.vy = Math.sin(angle) * ball.speed;
      // Nudge out of overlap
      ball.x = p === left ? p.x() + p.r() + ball.r + 2 : p.x() - p.r() - ball.r - 2;
      score++;
      if(score>best){ best=score; localStorage.setItem(storageBestKey, String(best)); bestEl.textContent=best; }
      updateHUD();
      if(!firstHit){ firstHit=true; showZones=false; zones.classList.remove('show'); }
      hitSound(); vibe(8);
    }
  }

  // Render helpers
  function draw(){
    // Background
    ctx.fillStyle = '#071018';
    ctx.fillRect(0,0,W,H);

    // Center line
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#a9b6c6';
    ctx.setLineDash([10*DPR, 14*DPR]); ctx.lineWidth = 2*DPR;
    ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.setLineDash([]); ctx.globalAlpha = 1;

    // Top/Bottom guard lines
    ctx.globalAlpha = 0.08;
    ctx.beginPath(); ctx.moveTo(0, wall.top); ctx.lineTo(W, wall.top); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, wall.bottom()); ctx.lineTo(W, wall.bottom()); ctx.stroke();
    ctx.globalAlpha = 1;

    // Paddles
    drawPaddle(left); drawPaddle(right);

    // Ball
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();

    // Soft glow
    ctx.globalAlpha = .22;
    ctx.beginPath(); ctx.fillStyle = '#00ffff';
    ctx.arc(ball.x, ball.y, ball.r*2.2,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function drawPaddle(p){
    const g = ctx.createLinearGradient(p.x()-p.r(),0,p.x()+p.r(),0);
    g.addColorStop(0, p.color);
    g.addColorStop(1, '#ffffff');
    ctx.beginPath();
    ctx.fillStyle=g;
    ctx.arc(p.x(), p.y, p.r(), 0, Math.PI*2);
    ctx.fill();
    // ring
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth = 2*DPR;
    ctx.beginPath(); ctx.arc(p.x(), p.y, p.r()+1.5*DPR, 0, Math.PI*2); ctx.stroke();
  }

  // Loop
  let last=performance.now();
  function tick(now){
    const dt = Math.min(0.032, (now - last)/1000); // cap dt
    last = now;

    if(running && !paused && !countdown){
      // Move ball
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Wall bounce
      if(ball.y - ball.r <= wall.top){
        ball.y = wall.top + ball.r + 1;
        ball.vy *= -1; wallSound();
      } else if(ball.y + ball.r >= wall.bottom()){
        ball.y = wall.bottom() - ball.r - 1;
        ball.vy *= -1; wallSound();
      }

      // Paddle collisions
      collidePaddle(left); collidePaddle(right);

      // Miss (left or right)
      if(ball.x + ball.r < 0 || ball.x - ball.r > W){
        lives--;
        updateHUD();
        missSound(); vibe([20,40,20]);
        if(lives<=0){
          running=false; paused=false;
          // Show Game Over
          startOverlay.querySelector('h1').textContent = 'Game Over';
          startOverlay.querySelector('.row #howBtn').textContent = 'How to play';
          startOverlay.classList.add('show');
          startBtn.textContent = 'Play again';
        }else{
          // Reset towards side that just missed
          const towards = (ball.x + ball.r < 0) ? 'L' : 'R';
          resetBall(towards, false);
          countdownGo(()=>{});
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Prevent accidental scroll/zoom
  document.addEventListener('gesturestart', e=>e.preventDefault());
  document.addEventListener('dblclick', e=>e.preventDefault());

  // Utilities
  // Show zones briefly at first launch
  zones.classList.add('show');
})();
</script>
</body>
</html>
